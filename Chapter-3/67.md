\*\*
For this exercise, we will examine the code generated by GCC for functions that have structures as arguments and return values, and from this see how these language features are typically implemented.

The following C code has a function process having structures as argument and return values, and a function `eval` that calls process:

```c
typedef struct {
    long a[2];
    long *p;
} strA;

typedef struct {
    long u[2];
    long q;
} strB;

strB process(strA s) {
    strB r;
    r.u[0] = s.a[1];
    r.u[1] = s.a[0];
    r.q =    *s.p;
    return r;
}

long eval(long x, long y, long z) {
    strA s;
    s.a[0] = x;
    s.a[1] = y;
    s.p = &z;
    strB r = process(s);
    return r.u[0] + r.u[1] + r.q;
}
```

GCC generates the following code for these two functions:

```asm
# strB process(strA s)
process:
  movq    %rdi, %rax
  movq    24(%rsp), %rdx
  movq    (%rdx), %rdx
  movq    16(%rsp), %rcx
  movq    %rcx, (%rdi)
  movq    8(%rsp), %rcx
  movq    %rcx, 8(%rdi)
  movq    %rdx, 16(%rdi)
  ret

# long eval(long x, long y, long z)
# x in %rdi, y in %rsi, z in %rdx
eval:
  subq    $104, %rsp
  movq    %rdx, 24(%rsp)
  leaq    24(%rsp), %rax
  movq    %rdi, (%rsp)
  movq    %rsi, 8(%rsp)
  movq    %rax, 16(%rsp)
  leaq    64(%rsp), %rdi
  call    process
  movq    72(%rsp), %rax
  addq    64(%rsp), %rax
  addq    80(%rsp), %rax
  addq    $104, %rsp
  ret
```

### A.
We can see on line 2 of function `eval` that it allocates 104 bytes on the stack. Diagram the stack frame for `eval`, showing the values that it stores on the stack prior to calling `process`.

### B.
What value does `eval` pass in its call to `process`?

### C.
How does the code for `process` access the elements of structure arguments?

### D.
How does the code for `process` set the fields of result struct `r`?

### E.
Complete your diagram of the stack frame for `eval`, showing how `eval` accesses the elements of structure `r` following the return from `process`.

### F.
What general principles can you discern about how structure values are passed as function arguments and how they are returned as function results?

## Answer

### The diagram

```text
+---------+ <- %rsp + 104
|         |
+---------+ <- %rsp + 96
|         |
+---------+ <- %rsp + 88
|  & s.p  |
+         + <- %rsp + 80
| &s.a[1] |
+         + <- %rsp + 72
| &s.a[0] |
+---------+ <- %rsp + 64 (%rdi of process)
|         |
+---------+ <- %rsp + 56
|         |
+---------+ <- %rsp + 48
|         |
+---------+ <- %rsp + 40
|         |
+---------+ <- %rsp + 32
|    z    |
+---------+ <- %rsp + 24
|   & z   |
+         + <- %rsp + 16
|    y    |
+         + <- %rsp + 8
|    x    |
+---------+ <- %rsp of eval
|         | <- call process
+---------+ <- %rsp of process
```

### B.
The `eval` mov the address of strA to %rdi and call `process`.

### C.
The `process` access the structure through stack, the base of structure argument is 8(%rsp).

### D.
The address of return structure was passed by %rdi, so `process` just access through offset(%rdi).

### F.
When the sizeof arguments is bigger than 16, the value was passed through stack, and a register for the address of the structure. Otherwise the value was passed throught registers.
