\*\*\*

Your assignment will be to write a Y86-64 program to perform bubblesort. For reference, the following C function implements bubblesort using array referencing:

```c
/* Bubble sort: Array version */
void bubble_a(long *data, long count) {
    long i, last;
    for (last = count-1; last > 0; last--) {
        for (i = 0; i < last; i++)
            if (data[i+1] < data[i]) {
                /* Swap adjacent elements */
                long t = data[i+1];
                data[i+1] = data[i];
                data[i] = t;
            }
    }
}
```

### A.
Write and test a C version that references the array elements with pointers, rather than using array indexing.

### B.
Write and test a Y86-64 program consisting of the function and test code.  You may find it useful to pattern your implementation after x86-64 code generated by compiling your C code. Although pointer comparisons are normally done using unsigned arithmetic, you can use signed arithmetic for this exercise.

## Answer

### A.
```c
void bubble(long *begin, long *end) {
    for (long t, *p, *q; begin != end; --end)
        for (q = begin, p = q++; q != end; p = q++)
            if (*p > *q) t = *p, *p = *q, *q = t;
}
```

### B.

```asm
bubble:
    irmovq  $8, %r8
begin:
    rrmovq  %rsi, %rax
    xorq    %rdi, %rax
    je      sorted
    subq    %r8, %rsi
    rrmovq  %rdi, %rcx
    rrmovq  %rdi, %rdx
round:
    rrmovq  %rcx, %rax
    xorq    %rsi, %rax
    je      begin
    addq    %r8, %rdx
    mrmovq  (%rcx), %r10
    mrmovq  (%rdx), %r11
    rrmovq  %r10, %rax
    subq    %r11, %rax
    jle     noswap
    rmmovq  %r10, (%rdx)
    rmmovq  %r11, (%rcx)
noswap:
    addq    %r8, %rcx
    jmp     round
sorted:
    ret
```

Originally I wrote an x86-64 version of bubble sort.

```asm
bubble:
    cmpq    %rdi, %rsi
    je      sorted
    subq    $8, %rsi
    movq    %rdi, %rcx
    movq    %rdi, %rdx
round:
    cmpq    %rsi, %rcx
    je      bubble
    addq    $8, %rdx
    movq    (%rcx), %r8
    movq    (%rdx), %r9
    cmpq    %r8, %r9
    jge     noswap
    movq    %r8, (%rdx)
    movq    %r9, (%rcx)
noswap:
    addq    $8, %rcx
    jmp     round
sorted:
    ret
```
